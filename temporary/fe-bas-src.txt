#include "../../../lib/libmain.bas"
#include "../../../lib/libvecfont.bas"
#include "../../../lib/libglue.bas"
#include "../../mod/platform.bas"

namespace ImageMap
    const as string   _
            S_WIDTH       = "w",  _
            S_HEIGHT      = "h"
            
    dim as DICTSTRING _maps

    declare function init() as integer
    declare function loadImageMap( id as string, src as string ) as integer
    declare function deleteImageMap( id as string ) as integer
    declare function drawSegment( map as string, segment as string, x as integer, y as integer, a as integer = -1 ) as integer
    declare function drawSegmentTo( context as any ptr, map as string, segment as string, x as integer, y as integer, a as integer = -1 ) as integer
    declare function getSegmentValue( map as string, segment as string, value as string ) as integer
    declare function _decodeRect( rect as string ) as DICTSTRING

    function init() as integer
        ImageMap._maps = Dict.create()
        return TRUE
    end function
    
    function loadImageMap( id as string, src as string ) as integer
        dim as string d = Utils.readFile( src )
        if( len( d ) = 0 ) then
            return 0        ' unable to load or invalid map
        end if
        
        dim as DICTSTRING map = Dict.create()
        dim as string image_src = ""
        dim as string k, v
        dim as integer s = 1, e = instr( d, ";" ), b
        while( e > 0 )
            v = trim( mid( d, s, (e - s) ), any !"\n\r\t " )
            if( (len( v ) > 0) and (asc( v, 1 ) <> 35) ) then       ' 35 => #
                b = instr( v, "=" )
                if( b > 0 ) then
                    k = lcase( mid( v, 1, (b - 1) ) )
                    v = mid( v, (b + 1) )
                    if( asc( k, 1 ) = 46 ) then     ' 46 is .
                        if( k = ".img" ) then
                            image_src = v
                        end if
                    else
                        Dict.set( map, k, ImageMap._decodeRect( v ) )
                    end if
                end if
            end if
            s = (e + 1)
            e = instr( s, d, ";" )
        wend
        
        dim as integer bmpwidth, bmpheight
        dim as integer ff = freefile()
        if( open( image_src for binary access read as #ff ) <> 0 ) then
            return FALSE
        end if
        
        ' retrieve BMP dimensions
        get #ff, 19, bmpwidth
        get #ff, 23, bmpheight

        close #ff        
        
        dim as any ptr img = imagecreate( bmpwidth, bmpheight )
        
        if( bload( image_src, img ) <> 0 ) then
            imagedestroy( img )
            return FALSE
        end if

        Dict.set( map, "_ptr", cint( img ) )
       
        Dict.set( ImageMap._maps, id, map )
        return TRUE
    end function
    
    function deleteImageMap( id as string ) as integer
        if( Dict.containsKey( ImageMap._maps, id ) ) then
            Dict.remove( ImageMap._maps, id )
            return TRUE
        end if
        return FALSE
    end function
        
    
    function drawSegment( map as string, segment as string, x as integer, y as integer, a as integer = -1 ) as integer
        return ImageMap.drawSegmentTo( 0, map, segment, x, y, a )
    end function
    
    function drawSegmentTo( context as any ptr, map as string, segment as string, x as integer, y as integer, a as integer = -1 ) as integer
        if( Dict.containsKey( ImageMap._maps, map ) ) then
            dim as DICTSTRING mapd = Dict.valueOf( ImageMap._maps, map )
            if( Dict.containsKey( mapd, segment ) ) then
                dim as DICTSTRING box = Dict.valueOf( mapd, segment )
                dim as any ptr ip = cptr( any ptr, Dict.intValueOf( mapd, "_ptr" ) )
                dim as integer dx1 = Dict.intValueOf( box, "x" )
                dim as integer w = Dict.intValueOf( box, "w" )
                select case a
                    case 1:
                        dx1 -= (w / 2)
                    case 2:
                        dx1 -= w
                end select
                dim as integer  _
                        dy1 = Dict.intValueOf( box, "y" ),  _
                        dx2 = (w + dx1 - 1),  _
                        dy2 = (Dict.intValueOf( box, "h" ) + dy1 - 1)
                if( context <> 0 ) then
                    put context, (x, y), ip, (dx1, dy1)-(dx2, dy2), PSet
                else
                    put (x, y), ip, (dx1, dy1)-(dx2, dy2), PSet
                end if
                return TRUE
            end if
        end if
        return FALSE
    end function
    
    function getSegmentValue( map as string, segment as string, value as string ) as integer
        if( Dict.containsKey( ImageMap._maps, map ) ) then
            dim as DICTSTRING mapd = Dict.valueOf( ImageMap._maps, map )
            if( Dict.containsKey( mapd, segment ) ) then
                dim as DICTSTRING box = Dict.valueOf( mapd, segment )
                return Dict.intValueOf( box, value, -1 )
            end if
        end if
        return -1
    end function

    function _decodeRect( rect as string ) as DICTSTRING
        dim as integer i = 1
        dim as integer sl, idx = 0
        dim as DICTSTRING seg = Dict.create()
        sl = (asc( rect, i ) - 48)
        i += 2
        Dict.set( seg, "x", val( mid( rect, i, sl ) ) )
        i += sl
        Dict.set( seg, "y", val( mid( rect, i, sl ) ) )
        i += sl
        Dict.set( seg, "w", val( mid( rect, i, sl ) ) )
        i += sl
        Dict.set( seg, "h", val( mid( rect, i, sl ) ) )
        return seg
    end function
end namespace

namespace FrontEnd
    const as string  _
            D_WINDOW_FLAGS     = "window.flags",  _
            D_LAST_HIT_BUTTON     = "lasthitbutton",  _
            D_CLOSE_HANDLER       = "handler.close",  _
            D_SHOW_HITZONES       = "hitzones.show"
            
    declare function init() as integer
    declare function readConfigFile( src as string ) as DICTSTRING
    declare function hittest( x as integer, y as integer ) as DICTSTRING ptr        ' POINTER!
    declare function keytest( keycode as string ) as DICTSTRING
    declare sub setData( key as string, value as string )
    declare function getData( key as string ) as string
    declare sub hilightNext()
    declare function getHilightedAction() as string
    declare function glueCommand( byref w as string, byref vars as string ) as integer
    declare function _loadResource( src as string, w as DICTSTRING ptr ) as integer
    declare function _removeResource( id as string ) as integer
    declare function _buttonize( id as string, d as DICTSTRING ptr ) as integer
    declare function _drawAs( id as string, d as DICTSTRING ptr ) as integer
    declare function _writeAs( id as string, d as DICTSTRING ptr ) as integer
    declare function _paintRectAs( id as string, d as DICTSTRING ptr, filled as integer ) as integer
    declare sub _hilight()
    declare sub _clear()
    'declare function _drawResourceImage( id as string, byref d as DICTSTRING ) as integer
    declare function _addButton( id as string, d as DICTSTRING ptr ) as integer
    declare sub _drawText( text as string, d as DICTSTRING ptr )
    declare function _decodeColour( clr as string ) as integer
    declare function _onKeyGoto( key as string, d as DICTSTRING ptr ) as integer
    declare function _doAction( action as string, d as DICTSTRING ptr ) as integer
    declare function _isUniqueId( id as string ) as integer
    declare sub _updateStyle( d as DICTSTRING ptr )
    declare sub _setStyle( id as string, d as DICTSTRING )
    
    dim as DICTSTRING _buttons(255)
    dim as DICTSTRING _keymap
    dim as DICTSTRING _ids
    dim as DICTSTRING _styles
    dim as integer _buttons_last
    dim as integer _clr_0, _clr_1
    dim as DICTSTRING _data
    dim as integer _selected
    dim as any ptr _draw_context
    dim as integer _width, _height
    
    function init() as integer
        FrontEnd._clr_0 = RGB( 0, 0, 0 )
        FrontEnd._clr_1 = RGB( 255, 0, 0 )
        FrontEnd._clear()
        FrontEnd._data = Dict.create()
        FrontEnd.setData( FrontEnd.D_CLOSE_HANDLER, "" )
        FrontEnd.setData( FrontEnd.D_LAST_HIT_BUTTON, "" )
        return Glue.addPlugin( @FrontEnd.glueCommand )
    end function

    ' reads a config file (k=v; per line)
    function readConfigFile( src as string ) as DICTSTRING
        dim as string d = Utils.readFile( src )
        if( len( d ) = 0 ) then
            return ""        ' unable to load or invalid map
        end if
        
        dim as DICTSTRING map = Dict.create()
        dim as string k, v
        dim as integer s = 1, e = instr( d, ";" ), b
        while( e > 0 )
            v = trim( mid( d, s, (e - s) ), any !"\n\r\t " )
            if( (len( v ) > 0) and (asc( v, 1 ) <> 35) ) then       ' 35 => #
                b = instr( v, "=" )
                if( b > 0 ) then
                    k = lcase( mid( v, 1, (b - 1) ) )
                    v = mid( v, (b + 1) )
                    if( Dict.containsKey( map, k ) ) then
                        v = (Dict.valueOf( map, k ) & !"\n" & v)
                    end if
                    Dict.set( map, k, v )
                end if
            end if
            s = (e + 1)
            e = instr( s, d, ";" )
        wend
        return map
    end function

    ' this returns a pointer to save allocating memory
    function hittest( x as integer, y as integer ) as DICTSTRING ptr
        dim as DICTSTRING ptr result = 0
        dim as integer show_zones = Dict.intValueOf( FrontEnd._data, D_SHOW_HITZONES, 0 )
        FrontEnd._selected = -1
        if( FrontEnd._buttons_last > -1 ) then
            dim as integer i, clr
            for i = 0 to FrontEnd._buttons_last
                dim as DICTSTRING ptr dp = @FrontEnd._buttons(i)
                dim as integer   _
                        x1 = Dict.intValueOf( *dp, "x1" ),  _
                        y1 = Dict.intValueOf( *dp, "y1" ),  _
                        x2 = Dict.intValueOf( *dp, "x2" ),  _
                        y2 = Dict.intValueOf( *dp, "y2" )
                if( (x >= x1) and (y >= y1) and (x <= x2) and (y <= y2) ) then
                    clr = FrontEnd._clr_1
                    result = dp
                    FrontEnd._selected = i
                    ' remove these if "else" and the 2 after are uncommented
                    line (x1,y1)-(x2,y2), clr, B
                    line ((x1+1),(y1+1))-((x2-1),(y2-1)), clr, B
                'else
                '    if( show_zones ) then
                '        clr = FrontEnd._clr_0
                '    else
                '        continue for
                '    end if
                end if
                'line (x1,y1)-(x2,y2), clr, B
                'line ((x1+1),(y1+1))-((x2-1),(y2-1)), clr, B
            next
        end if
        return result
    end function

    ' check the map for the given keycode and return the dict or ""
    function keytest( keycode as string ) as DICTSTRING
        if( Dict.containsKey( FrontEnd._keymap, keycode ) ) then
            return Dict.valueOf( FrontEnd._keymap, keycode )
        end if
        return ""
    end function
    
    sub repaint()
        if( FrontEnd._draw_context <> 0 ) then
            put (0, 0), FrontEnd._draw_context, PSet
        else
            Utils.echo( "[FrontEnd] Notice: context is unavailable" )
        end if
    end sub

    function getData( key as string ) as string
        return Dict.valueOf( FrontEnd._data, key )
    end function
    
    sub setData( key as string, value as string )
        Dict.set( FrontEnd._data, key, value )
    end sub

    sub hilightNext()
        if( FrontEnd._buttons_last > -1 ) then
            if( FrontEnd._selected < FrontEnd._buttons_last ) then
                FrontEnd._selected += 1
                FrontEnd._hilight()
                return
            end if
        end if
        FrontEnd._selected = -1
        FrontEnd._hilight()
    end sub

    sub hilightPrev()
        if( FrontEnd._buttons_last > -1 ) then
            if( FrontEnd._selected >= 0 ) then
                FrontEnd._selected -= 1
            else
                FrontEnd._selected = FrontEnd._buttons_last
            end if
            FrontEnd._hilight()
            return
        end if
        FrontEnd._selected = -1
        FrontEnd._hilight()
    end sub

    sub hilightNone()
        FrontEnd._selected = -1
        FrontEnd._hilight()
    end sub
    
    function getHilightedAction() as string
        if( FrontEnd._buttons_last > -1 ) then
            if( FrontEnd._selected > -1 ) then
                dim as DICTSTRING ptr d = @FrontEnd._buttons(FrontEnd._selected)
                FrontEnd.setData( FrontEnd.D_LAST_HIT_BUTTON, Dict.valueOf( *d, "id" ) )
                return Dict.valueOf( *d, "action" )
            end if
        end if
        return ""
    end function

    function glueCommand( byref w as string, byref vars as string ) as integer
        dim c as string = Dict.valueOf( w, "_" ), cs as string
        dim ts as string, tn as single, ti as integer
        if( instrrev( c, "f.", 1 ) > 0 ) then
            cs = mid( c, 3 )
        else
            return -1
        end if
        dim as string vv = Dict.valueOf( w, c )
        dim as string into = Dict.valueOf( w, "into" )
        select case cs
' data
            case "loadresource"
                return FrontEnd._loadResource( vv, @w )
            case "removeresource"
                return FrontEnd._removeResource( vv )
                
            ' view actions
            case "clear", "clearview"
                FrontEnd._clear()
                
            ' TODO: if using object orientated entities support this
            'case "remove"
            '    Dict.remove( FrontEnd._ids, vv )
                
            case "setwidth", "setviewwidth"
                FrontEnd._width = Dict.intValueOf( w, c )
                FrontEnd._height = Dict.intValueOf( w, "height" )
                dim as integer vf = (  _
                        Dict.intValueOf( w, "flags", 0 ) or   _
                        val( FrontEnd.getData( FrontEnd.D_WINDOW_FLAGS ) )  _
                    )
                if( (FrontEnd._width > 0) and (FrontEnd._height > 0) ) then
                    screenres FrontEnd._width, FrontEnd._height, 32, , vf
                else
                    Utils.echoError( ("[FrontEnd] Invalid View: w=" & FrontEnd._width & "; h=" & FrontEnd._height & "; f=" & vf) )
                    return 0
                end if
                FrontEnd._clear()
                FrontEnd._clr_1 = FrontEnd._decodeColour( Dict.valueOf( w, "hilight", "#f00" ) )
                FrontEnd._clr_0 = FrontEnd._decodeColour( Dict.valueOf( w, "border", "#000" ) )

            case "settitle"
                windowtitle vv
                
            case "drawas"
                return FrontEnd._drawAs( vv, @w )
            case "writeas", "addtext"
                return FrontEnd._writeAs( vv, @w )
            case "markas", "addbutton"
                if( FrontEnd._addButton( vv, @w ) = 0 ) then
                    return 0        ' already exists
                end if
            case "paintrectas"
                return FrontEnd._paintRectAs( vv, @w, FALSE )
            case "paintfilledrectas"
                return FrontEnd._paintRectAs( vv, @w, TRUE )
            case "clearactions"
                FrontEnd._buttons_last = -1
                FrontEnd._keymap = Dict.create()
                
            case "getlastactionid"
                SET_INTO( FrontEnd.getData( FrontEnd.D_LAST_HIT_BUTTON ) )
            case "doaction"
                return FrontEnd._doAction( vv, @w )

            'event handlers
            case "onkey"       'onkey KEY goto LABEL
                return FrontEnd._onKeyGoto( vv, @w )
                
            case "onclosegoto"
                FrontEnd.setData( FrontEnd.D_CLOSE_HANDLER, vv )
                
            case "exit", "stop"
                ' notify the parent loop that it must exit
                return -254     ' exit intepreter loop
                
            case else:
                return 0        ' ours (ui.*) but not recognised
        end select
        return 1                ' we handled it
    end function        

    sub _setStyle( id as string, d as DICTSTRING )
        Dict.set( FrontEnd._styles, id, d )
    end sub
    
    sub _updateStyle( d as DICTSTRING ptr )
        dim as string sid = Dict.valueOf( *d, "style" )
        if( len( sid ) > 0 ) then
            dim as DICTSTRING style = Dict.valueOf( FrontEnd._styles, sid )
            dim as string keys()
            dim as integer i, l = Dict.keys( style, keys() )
            for i = 0 to (l - 1)
                if( not Dict.containsKey( *d, keys(i) ) ) then
                    Dict.set( *d, keys(i), Dict.valueOf( style, keys(i) ) )
                end if
            next
        end if
    end sub

    function _doAction( action as string, w as DICTSTRING ptr ) as integer
        dim as string  _
                args = Dict.valueOf( *w, "args", Dict.valueOf( *w, "withargs" ) ),  _
                ok_label = Dict.valueOf( *w, "ondonegoto" )
        dim as string  _
                err_label = Dict.valueOf( *w, "onerrorgoto", ok_label ),  _
                not_label = Dict.valueOf( *w, "onunsupportedgoto", ok_label )
        
        select case action
            case "movewindowto"
                dim as integer b = instr( args, "," )
                if( b > 0 ) then
                    ' 100 is FB.SET_WINDOW_POS from fbgfx.bi
                    screencontrol 100, cint( mid( args, 1, (b - 1) ) ), cint( mid( args, (b + 1) ) )
                    Glue.setRedirectLabel( ok_label )
                else
                    Glue.setRedirectLabel( err_label )
                end if

            case else
                Glue.setRedirectLabel( not_label )
        end select
        return -2
    end function
    
    function _onKeyGoto( key as string, w as DICTSTRING ptr ) as integer
        dim as string code = ""
        if( len( key ) > 0 ) then
            if( asc( key, 1 ) = 35 ) then       ' 35 => #
                code = chr( cint( mid( key, 2 ) ) )
            elseif( asc( key, 1 ) = 36 ) then   ' 36 => $
                key = lcase( mid( key, 2 ) )
                select case key
                    case "escape", "esc"
                        code = chr( 27 )
                    case "enter", "return"
                        code = chr( 13 )
                    case "direction_up"         ' these map to the cursor pad
                        code = "8"
                    case "direction_down"
                        code = "2"
                    case "direction_right"
                        code = "6"
                    case "direction_left"
                        code = "4"
                    case "direction_fire"
                        code = "5"
                end select
            else
                code = key
            end if
        end if
        if( len( code ) > 0 ) then
            dim as DICTSTRING d = Dict.create()
            Dict.set( d, "label", Dict.valueOf( *w, "goto" ) )
            Dict.set( d, "id", Dict.valueOf( *w, "id" ) )
            Dict.set( FrontEnd._keymap, code, d )
            return 1
        else
            Utils.echoError( ("[FrontEnd] Invalid key code: " & key) )
            return 0
        end if
    end function

    function _loadResource( src as string, w as DICTSTRING ptr ) as integer
        dim as string id = Dict.valueOf( *w, "as" )
        if( ImageMap.loadImageMap( id, src ) = 0 ) then
            return 0        ' error
        end if
        return 1
    end function

    function _removeResource( id as string ) as integer
        ImageMap.deleteImageMap( id )
        return 1
    end function

    function _buttonize( id as string, d as DICTSTRING ptr ) as integer
        if( Dict.containsKey( *d, "onclickgoto" ) ) then
            FrontEnd._addButton( id, d )
        end if
        return TRUE
    end function

    function _drawAs( id as string, d as DICTSTRING ptr ) as integer
        if( not FrontEnd._isUniqueId( id ) ) then
            return 0
        end if
        dim as integer  _
                x = Dict.intValueOf( *d, "x", Dict.intValueOf( *d, "atx" ) ),  _
                y = Dict.intValueOf( *d, "y" ),  _
                a = Dict.intValueOf( *d, "align", 0 )
        dim as string entity = Dict.valueOf( *d, "id" )
        dim as integer i = instr( entity, "." )
        if( i > 0 ) then
            dim as string map = mid( entity, 1, (i - 1) )
            dim as string seg = mid( entity, (i + 1) )
            if( ImageMap.drawSegmentTo( FrontEnd._draw_context, map, seg, x, y, 0 ) ) then      ' align is disabled
                Dict.set( *d, "width", ImageMap.getSegmentValue( map, seg, ImageMap.S_WIDTH ) )
                Dict.set( *d, "height", ImageMap.getSegmentValue( map, seg, ImageMap.S_HEIGHT ) )
                if( FrontEnd._buttonize( id, d ) ) then
                    return 1
                end if
            end if
        else
            Utils.echoError( ("[FrontEnd] Invalid entity id: " & entity) )            
        end if
        return 0
    end function
    
    function _isUniqueId( id as string ) as integer
        ' TODO: if using object orientated entities support this
        'if( len( id ) = 0 ) then
        '    ' Note: currently a blank ID is valid as it means don't ID this
        '    '       in the future a random ID may be need to be returned to ensure
        '    '       ID based access is valid (if we add this)
        '    return TRUE
        'end if
        'if( Dict.containsKey( FrontEnd._ids, id ) = FALSE ) then
        '    Dict.set( FrontEnd._ids, id, "" )
        '    return TRUE
        'end if
        'Utils.echoError( ("[FrontEnd] id " & id & " is already in use") )
        'return FALSE
        return TRUE
    end function
    
    sub _clear()
        'color 0, RGB( 255, 255, 255 )
        'cls
        FrontEnd._buttons_last = -1
        FrontEnd._keymap = Dict.create()
        FrontEnd._ids = Dict.create()
        FrontEnd._styles = Dict.create()
        FrontEnd._selected = -1
        if( FrontEnd._draw_context <> 0 ) then
            imagedestroy( FrontEnd._draw_context )
            FrontEnd._draw_context = 0
        end if
        if( (FrontEnd._width > 0) and (FrontEnd._height > 0) ) then
            FrontEnd._draw_context = ImageCreate(  _
                    FrontEnd._width,  _
                    FrontEnd._height  _
                )
        end if
    end sub
    
    sub _hilight()
        if( FrontEnd._buttons_last > -1 ) then        
            FrontEnd.repaint()
            dim as integer i, clr
            for i = 0 to FrontEnd._buttons_last
                dim as DICTSTRING ptr dp = @FrontEnd._buttons(i)
                dim as integer   _
                        x1 = Dict.intValueOf( *dp, "x1" ),  _
                        y1 = Dict.intValueOf( *dp, "y1" ),  _
                        x2 = Dict.intValueOf( *dp, "x2" ),  _
                        y2 = Dict.intValueOf( *dp, "y2" )
                if( i = FrontEnd._selected ) then
                    clr = FrontEnd._clr_1
                else
                    clr = FrontEnd._clr_0
                end if
                line (x1,y1)-(x2,y2), clr, B
                line ((x1+1),(y1+1))-((x2-1),(y2-1)), clr, B
            next
        end if
    end sub
    
    function _addButton( id as string, d as DICTSTRING ptr ) as integer
        ' allow multiple buttons with the same id..?
        'if( FrontEnd._buttons_last > -1 ) then
        '    dim as DICTSTRING ptr dp
        '    dim as integer i
        '    for i = 0 to FrontEnd._buttons_last
        '        dp = @FrontEnd._buttons(i)
        '        if( Dict.valueOf( *dp, "id" ) = id ) then
        '            Utils.echoError( "[FrontEnd] Button with id '" & id & "' already defined" )
        '            return FALSE
        '        end if
        '    next
        'end if
        dim as DICTSTRING def = Dict.create()
        Dict.set( def, "id", id )
        dim as integer  _
                x = Dict.intValueOf( *d, "x", Dict.intValueOf( *d, "atx" ) ),  _
                y = Dict.intValueOf( *d, "y", Dict.intValueOf( *d, "aty" ) ),  _
                w = Dict.intValueOf( *d, "width" ),  _
                h = Dict.intValueOf( *d, "height" )
        Dict.set( def, "x1", x )
        Dict.set( def, "y1", y )
        Dict.set( def, "x2", (w + x - 1) )
        Dict.set( def, "y2", (h + y - 1) )
        Dict.set( def, "action", Dict.valueOf( *d, "onclickgoto" ) )
        FrontEnd._buttons_last += 1
        FrontEnd._buttons(FrontEnd._buttons_last) = def

        dim as string border = Dict.valueOf( *d, "border", "" )
        if( len( border ) > 0 ) then
            line FrontEnd._draw_context, (x, y)-STEP (w, h), FrontEnd._decodeColour( border ), B
        end if

        FrontEnd.hittest( -1, -1 )      ' draws the rectangles for unhilighted buttons
        
        return TRUE
    end function

    function _writeAs( id as string, d as DICTSTRING ptr ) as integer
        if( not FrontEnd._isUniqueId( id ) ) then
            return 0
        end if
        dim as integer  _
                x = Dict.intValueOf( *d, "x", Dict.intValueOf( *d, "atx" ) ),  _
                y = Dict.intValueOf( *d, "y" ),  _
                w = Dict.intValueOf( *d, "width" ),  _
                h = Dict.intValueOf( *d, "height" ),  _
                fg = FrontEnd._decodeColour(  _
                        Dict.valueOf( *d, "colour", Dict.valueOf( *d, "fg", "#000000" ) )  _
                    ),  _
                bg = FrontEnd._decodeColour(  _
                        Dict.valueOf( *d, "background", Dict.valueOf( *d, "bg", "#ffffff" ) )  _
                    ),  _
                size = Dict.intValueOf( *d, "size", 2 ),  _
                thickness = Dict.intValueOf( *d, "thickness", 2 )
        dim as string text = Dict.valueOf( *d, "value", Dict.valueOf( *d, "text" ) )
        dim as string align = Dict.valueOf( *d, "align", "2" )
        if( (align = "2") or (align = "centre") ) then
            x += ((w - (VecText.getGlyphWidth( size, thickness ) * len( text ))) / 2)
        elseif( (align = "1") or (align = "right") ) then
            x += ((w - (VecText.getGlyphWidth( size, thickness ) * len( text ))))
        end if
        y += ((h - VecText.getGlyphHeight( size, thickness )) / 2)
        VecText.useContext( FrontEnd._draw_context )
        VecText.drawStringWithBackground( text, fg, bg, x, y, size, thickness, thickness )
        if( FrontEnd._buttonize( id, d ) ) then
            return 1
        end if
        return 0
    end function

    function _paintRectAs( id as string, d as DICTSTRING ptr, filled as integer ) as integer
        if( not FrontEnd._isUniqueId( id ) ) then
            return 0
        end if
        dim as integer  _
                x = Dict.intValueOf( *d, "x", Dict.intValueOf( *d, "atx" ) ),  _
                y = Dict.intValueOf( *d, "y" ),  _
                w = Dict.intValueOf( *d, "width" ),  _
                h = Dict.intValueOf( *d, "height" ),  _                
                fg = FrontEnd._decodeColour(  _
                        Dict.valueOf( *d, "colour", Dict.valueOf( *d, "fg", "#000000" ) )  _
                    )
        if( filled = TRUE ) then
            line FrontEnd._draw_context, (x, y)-STEP (w, h), fg, BF
        else
            line FrontEnd._draw_context, (x, y)-STEP (w, h), fg, B
        end if
        if( FrontEnd._buttonize( id, d ) ) then
            return 1
        end if
        return 0
    end function

    function _decodeColour( clr as string ) as integer
        if( asc( clr, 1 ) = asc( "#" ) ) then
            clr = mid( clr, 2 )
        end if
        if( len( clr ) = 3 ) then
            return RGB(   _
                    val( ("&h" & mid( clr, 1, 1 ) & mid( clr, 1, 1 )) ),  _
                    val( ("&h" & mid( clr, 2, 1 ) & mid( clr, 2, 1 )) ),  _
                    val( ("&h" & mid( clr, 3, 1 ) & mid( clr, 3, 1 )) )  _
                )
        elseif( len( clr ) = 6 ) then
            return RGB(   _
                    val( ("&h" & mid( clr, 1, 2 )) ),  _
                    val( ("&h" & mid( clr, 3, 2 )) ),  _
                    val( ("&h" & mid( clr, 5, 2 )) )  _
                )
        end if
        return 0
    end function
        

end namespace

VecText.init()
Glue.init()
ExtPlatform.init()
ImageMap.init()
FrontEnd.init()

dim as DICTSTRING vars = Utils.parseCommandLine( Dict.create(), Utils.PCL_UCASE )

dim as string appfile = Dict.valueOf( vars, "_" )
dim as string morse_key = Dict.valueOf( vars, "MORSEKEY", " " )
FrontEnd.setData( FrontEnd.D_WINDOW_FLAGS, Dict.valueOf( vars, "WINDOW_FLAGS" ) )

if( len( appfile ) = 0 ) then
    dim as string exe = command(0)
    dim as integer l = (len( exe ) - 3)
    if( lcase( mid( exe, l ) ) = ".exe" ) then
        exe = mid( exe, 1, (l - 1) )
    end if
    appfile = (exe & ".app")
end if

' Load the definition, exit if unable to load
dim as DICTSTRING appdef = FrontEnd.readConfigFile( appfile )
if( len( appdef ) = 0 ) then
    Utils.echoError( ("[FrontEnd] Unable to open file: " & appfile) )
    end
end if

' Get the script file, exit if empty
dim as string scriptfile = Dict.valueOf( appdef, "script" )
if( len( scriptfile ) = 0 ) then
    Utils.echoError( ("[FrontEnd] Invalid application manifest: " & appfile) )
    end
end if

' Parse the variables list and insert into our existing variables dict
dim as string vardefs = Dict.valueOf( appdef, "var" )
if( len( vardefs ) > 0 ) then
    vardefs = (vardefs & "\n")
    dim as integer vi = instr( vardefs, !"\n" ), vb
    dim as string vardef
    while( vi > 0 )
        vardef = mid( vardefs, 1, (vi - 1) )
        vb = instr( vardef, "=" )
        if( vb > 0 ) then
            Dict.set( vars,  _
                    mid( vardef, 1, (vb - 1) ),  _
                    mid( vardef, (vb + 1) )  _
                )
        end if
        vardefs = mid( vardefs, (vi + 1) )
        vb = instr( vardefs, !"\n" )
    wend
end if

' Load the scriptfile, exit if unable to read
dim as integer ern = 0
dim as string script = Utils.readFile( scriptfile, ern )
if( ern <> 0 ) then
    Utils.echoError( ("[FrontEnd] Unable to read '" & scriptfile & "'") )
    end
end if

' Load the script into Glue
Glue.load( script, vars )


' Main loop
dim as integer res
dim as string label
dim as integer mx, my, mb
dim as DICTSTRING ptr hit, lasthit = 0
dim as string key, closewindow = (chr( 255 ) & "k")
dim as integer running = TRUE
dim as integer ox = -1, oy = -1
dim as double timeout = -1
while( running )
    res = Glue.run( label )
    FrontEnd.repaint()
    select case res
        case 0:
            Utils.echoError( "[FrontEnd] Glue Error" )
            exit while
        case -254:
            running = FALSE
            exit while
    end select
    
    while( TRUE )
        getmouse( mx, my, , mb )
        if( (ox <> mx) or (oy <> my) or (mb > 0) ) then
            ox = mx
            oy = my
            hit = FrontEnd.hittest( mx, my )
            if( hit <> lasthit ) then
                FrontEnd.repaint()
                lasthit = hit
            end if
            if( (hit <> 0) and (mb > 0) ) then
                while( mb > 0 )
                    getmouse mx, my, , mb
                    sleep 15, 1
                wend
                FrontEnd.setData( FrontEnd.D_LAST_HIT_BUTTON, Dict.valueOf( *hit, "id" ) )
                label = Dict.valueOf( *hit, "action" )
                if( len( label ) = 0 ) then
                    Utils.echoError( "[FrontEnd] No action specified for button" )
                    running = FALSE
                end if
                exit while
            end if
        end if
        
        key = inkey()
        if( len( key ) > 0 ) then
            timeout = -1
            if( (key = chr( 27 )) or (key = closewindow) ) then
                dim as string ex = FrontEnd.getData( FrontEnd.D_CLOSE_HANDLER )
                if( len( ex ) > 0 ) then
                    label = ex
                    exit while
                else
                    end
                end if
            elseif( key = morse_key ) then
                FrontEnd.hilightNext()
                timeout = (timer() + 1)
            elseif( (key = chr( 13 )) or (key = chr( 10 )) ) then
                timeout = -1
                label = FrontEnd.getHilightedAction()
                FrontEnd.hilightNone()
                if( len( label ) > 0 ) then
                    exit while
                end if
            elseif( asc( key, 1 ) = 255 ) then
                select case asc( key, 2 )
                    case 80:
                        FrontEnd.hilightNext()
                    case 72:
                        FrontEnd.hilightPrev()
                end select
            else
                key = FrontEnd.keytest( key )
                if( len( key ) > 0 ) then
                    FrontEnd.setData( FrontEnd.D_LAST_HIT_BUTTON, Dict.valueOf( key, "id" ) )
                    label = Dict.valueOf( key, "label" )
                    exit while
                end if
            end if
        end if
        
        if( (timeout > -1) and (timer() > timeout) ) then
            timeout = -1
            label = FrontEnd.getHilightedAction()
            FrontEnd.hilightNone()
            if( len( label ) > 0 ) then
                exit while
            end if
        end if
        
        sleep 15, 1
    wend
wend
